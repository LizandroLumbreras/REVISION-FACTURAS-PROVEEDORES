<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8">
<title>Comparador CotizaciÃ³n vs Factura (BD)</title>

<script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2.39.7/dist/umd/supabase.min.js"></script>

<style>
body{font-family:Arial;background:#f4f6f9;padding:20px}
select,button,input{padding:8px;margin:4px}
button{background:#00416A;color:#fff;border:none;cursor:pointer}
table{width:100%;border-collapse:collapse;margin-top:20px;background:#fff}
th,td{border:1px solid #ccc;padding:6px;text-align:center}
th{background:#00416A;color:#fff}
.total{margin-top:15px;font-size:18px;font-weight:bold;color:#b00020}
input[type=number]{width:70px}
tr.falta{background:#fff6c2}
</style>
</head>

<body>

<h2>ðŸ“Š Comparador CotizaciÃ³n vs Factura (BD)</h2>

<label>Proveedor:</label>
<select id="proveedor">
  <option value="">-- Selecciona --</option>
  <option value="ABARROTES">ABARROTES</option>
  <option value="DECASA">DECASA</option>
  <option value="MAS BODEGA">MAS BODEGA</option>
</select>

<button onclick="buscarFacturas()">Buscar facturas</button>

<div id="listaFacturas"></div>

<hr>

<label>CotizaciÃ³n (Excel):</label>
<input type="file" id="excelFile" accept=".xlsx,.xls">

<table>
<thead>
<tr>
  <th>Producto</th>
  <th>Cotizado</th>
  <th>Factura</th>
  <th>Pzas x Caja</th>
  <th>Diferencia</th>
  <th>A descontar</th>
</tr>
</thead>
<tbody id="tabla"></tbody>
</table>

<div class="total" id="total"></div>

<script>
/* ================= SUPABASE ================= */
const supa = supabase.createClient(
  "https://cvpbtjlupswbyxenugpz.supabase.co",
  "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImN2cGJ0amx1cHN3Ynl4ZW51Z3B6Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDc3MDIxOTQsImV4cCI6MjA2MzI3ODE5NH0.iiJsYM3TtaGPdeCtPcEXwAz3LfFc1uJGECEvOErvrqY"
);

let conceptosFactura = [];
let cotizadosCache = [];

/* ================= UTILIDADES ================= */
function normalizar(t){
  return String(t ?? "").toUpperCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g,"")
    .replace(/\./g," ")
    .replace(/[+]/g," ")
    .replace(/[^A-Z0-9\s/]/g," ")
    .replace(/\s+/g," ")
    .trim();
}

function limpiarNumero(v){
  if (v === null || v === undefined) return 0;
  // soporta "11.45", "$ 11.45", "11,45"
  const s = String(v).replace(/\$/g,"").replace(/,/g,".").replace(/\s/g,"");
  const n = parseFloat(s);
  return isNaN(n) ? 0 : n;
}

function extraerPiezas(desc){
  const m = String(desc ?? "").match(/(\d+)\s*\/\s*\d+/);
  return m ? parseInt(m[1]) : null;
}

/* ---- tokens fuertes para matching ---- */
const STOP = new Set([
  "PARA","CON","DEL","DE","LA","EL","LOS","LAS","Y","EN","AL","UN","UNA","UNO",
  "MAS","PROMO","PROMOCION","PRODUCTO","EXTRA","PACK","PAQ","PQT","CJA","CAJA"
]);

function tokenNorm(tok){
  tok = tok.replace(/[^A-Z0-9]/g,"");
  if (!tok) return "";
  // singular bÃ¡sico (GALLETAS->GALLETA, MARIAS->MARIA, MARAVILLAS->MARAVILLA)
  if (tok.length >= 5 && tok.endsWith("S")) tok = tok.slice(0, -1);
  // quita unidades frecuentes como token
  if (["GR","GRM","G","KG","ML","LT","L","PZ","PZA","PZA.","PZAS"].includes(tok)) return "";
  if (STOP.has(tok)) return "";
  // descarta tokens muy cortos
  if (tok.length < 3) return "";
  // descarta tokens que sean solo nÃºmeros
  if (/^\d+$/.test(tok)) return "";
  return tok;
}

function tokensProducto(texto){
  const t = normalizar(texto)
    .replace(/\d+/g," ")               // quita nÃºmeros
    .replace(/\b(GR|GRM|G|KG|ML|LT|L|PZ|PZA|PZAS)\b/g," ") // quita unidades sueltas
    .replace(/\s+/g," ")
    .trim();

  return t.split(" ").map(tokenNorm).filter(Boolean);
}

function scoreMatch(tokensA, tokensB){
  if (!tokensA.length || !tokensB.length) return {score:0, hits:0};
  const setB = new Set(tokensB);
  let hits = 0;
  for (const x of tokensA) if (setB.has(x)) hits++;
  const score = hits / Math.max(tokensA.length, tokensB.length);
  return {score, hits};
}

/* ================= BUSCAR FACTURAS ================= */
async function buscarFacturas(){
  const proveedorSel = document.getElementById("proveedor").value;
  if(!proveedorSel){ alert("Selecciona proveedor"); return }

  const { data, error } = await supa
    .from("deuda_limpia_pdd")
    .select("uuid_cfdi, fecha, total, conceptos_detalle, razon_social_emisor")
    .ilike("razon_social_emisor", `%${proveedorSel}%`)
    .order("fecha",{ascending:false})
    .limit(10);

  if(error){
    console.error(error);
    alert("Error al consultar BD");
    return;
  }

  let html = "<h4>Facturas:</h4><ul>";
  data.forEach(f=>{
    html += `
      <li>
        ${String(f.fecha).split("T")[0]} â€” $${f.total}
        <button onclick='usarFactura(${JSON.stringify(f.conceptos_detalle)})'>Usar</button>
      </li>`;
  });
  html += "</ul>";
  document.getElementById("listaFacturas").innerHTML = html;
}

/* ================= USAR FACTURA ================= */
function usarFactura(conceptos){
  // conceptos_detalle puede venir como array o como string JSON
  let arr = conceptos;
  if (typeof arr === "string") {
    try { arr = JSON.parse(arr); } catch(e) { arr = []; }
  }
  if (!Array.isArray(arr)) arr = [];

  conceptosFactura = arr.map(c=>({
    descripcionRaw: c.descripcion || "",
    descripcion: normalizar(c.descripcion),
    tokens: tokensProducto(c.descripcion),
    cajas: limpiarNumero(c.cantidad),
    precioCaja: limpiarNumero(c.valorUnitario),
    piezasCaja: extraerPiezas(c.descripcion)
  }));

  procesar();
}

/* ================= PROCESAR ================= */
async function procesar(){
  const proveedorSel = document.getElementById("proveedor").value;
  const file = document.getElementById("excelFile").files[0];

  if(!conceptosFactura.length || !file){
    alert("Selecciona factura y cotizaciÃ³n");
    return;
  }

  cotizadosCache = await leerExcel(file, proveedorSel);
  comparar(cotizadosCache, conceptosFactura);
}

/* ================= LEER EXCEL (MATRIZ POR PROVEEDOR) ================= */
function leerExcel(file, proveedorSel){
  return new Promise(resolve=>{
    const r = new FileReader();
    r.onload = e=>{
      const wb = XLSX.read(new Uint8Array(e.target.result),{type:'array'});

      const prov = normalizar(proveedorSel);

      // 1) Buscar una hoja donde en alguna fila estÃ© el nombre del proveedor (encabezado matriz)
      let best = null;

      for (const shName of wb.SheetNames){
        const ws = wb.Sheets[shName];
        const rows = XLSX.utils.sheet_to_json(ws,{header:1, raw:true});

        // Buscar fila que tenga "DESCRIPCION" y, arriba o en la misma, el proveedor
        let headerRowIdx = -1;
        for (let i=0; i<Math.min(rows.length, 20); i++){
          const row = rows[i] || [];
          const rowStr = row.map(x=>normalizar(x)).join(" | ");
          if (rowStr.includes("DESCRIPCION")) { headerRowIdx = i; break; }
        }
        if (headerRowIdx === -1) continue;

        // Buscar columna del proveedor en fila headerRowIdx-1 o headerRowIdx
        const r1 = rows[headerRowIdx-1] || [];
        const r2 = rows[headerRowIdx] || [];

        let colProv = -1;

        // intenta en fila de arriba (como tu matriz: fila 2 trae ABARROTES/DECASA)
        for (let j=0; j<r1.length; j++){
          if (normalizar(r1[j]) === prov) { colProv = j; break; }
        }
        // fallback: intenta en la misma fila
        if (colProv === -1){
          for (let j=0; j<r2.length; j++){
            if (normalizar(r2[j]) === prov) { colProv = j; break; }
          }
        }

        if (colProv === -1) continue;

        best = {shName, rows, start: headerRowIdx+1, colDesc: 0, colPrice: colProv};
        break;
      }

      // 2) Fallback si no se encontrÃ³ estructura matriz: hoja 1, col A desc, col B precio
      if (!best){
        const shName = wb.SheetNames[0];
        const ws = wb.Sheets[shName];
        const rows = XLSX.utils.sheet_to_json(ws,{header:1, raw:true});
        best = {shName, rows, start: 1, colDesc: 0, colPrice: 1};
      }

      const out = [];
      for (let i=best.start; i<best.rows.length; i++){
        const row = best.rows[i] || [];
        const desc = row[best.colDesc];
        if (!desc) continue;

        const precio = limpiarNumero(row[best.colPrice]);
        if (!precio || precio <= 0) continue;

        const descNorm = normalizar(desc);

        out.push({
          descripcionRaw: String(desc),
          descripcion: descNorm,
          tokens: tokensProducto(descNorm),
          precio
        });
      }

      resolve(out);
    };
    r.readAsArrayBuffer(file);
  });
}

/* ================= COMPARAR (MATCH POR SCORE) ================= */
function comparar(cotizados, facturados){
  const tbody = document.getElementById("tabla");
  tbody.innerHTML="";
  let total=0;

  facturados.forEach((f, idx)=>{
    // piezas
    const pzas = (f.piezasCaja && f.piezasCaja > 0) ? Number(f.piezasCaja) : 1;

    // precio unitario factura
    const precioUnitFact = f.precioCaja / pzas;

    // buscar mejor match
    let best = null;
    let bestScore = 0;
    let bestHits = 0;

    for (const x of cotizados){
      const {score, hits} = scoreMatch(f.tokens, x.tokens);
      if (score > bestScore || (score === bestScore && hits > bestHits)){
        bestScore = score;
        bestHits = hits;
        best = x;
      }
    }

    // umbral: 2 hits o score >= 0.55
    const ok = best && (bestHits >= 2 || bestScore >= 0.55);

    const precioCot = ok ? best.precio : 0;
    const diferencia = ok ? (precioUnitFact - precioCot) : 0;

    const descuento = (ok && diferencia > 0)
      ? diferencia * pzas * f.cajas
      : 0;

    total += descuento;

    tbody.innerHTML += `
      <tr class="${!ok ? 'falta' : (!f.piezasCaja ? 'falta' : '')}">
        <td>${f.descripcion}</td>
        <td>${ok ? precioCot.toFixed(2) : "â€”"}</td>
        <td>${precioUnitFact.toFixed(2)}</td>
        <td>
          <input type="number" min="1" value="${pzas}"
            onchange="actualizarPiezas(${idx}, this.value)">
        </td>
        <td>${diferencia.toFixed(2)}</td>
        <td>${descuento.toFixed(2)}</td>
      </tr>`;
  });

  document.getElementById("total").innerText =
    "TOTAL A DESCONTAR: $ " + total.toFixed(2);
}

/* ================= RECALCULO PZAS ================= */
function actualizarPiezas(idx, valor){
  const pzas = Math.max(1, parseInt(valor) || 1);
  conceptosFactura[idx].piezasCaja = pzas;
  comparar(cotizadosCache, conceptosFactura);
}
</script>

</body>
</html>
