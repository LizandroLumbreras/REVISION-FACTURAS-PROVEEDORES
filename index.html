<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8">
<title>Comparador CotizaciÃ³n vs Factura (BD)</title>

<script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2.39.7/dist/umd/supabase.min.js"></script>

<style>
body{font-family:Arial;background:#f4f6f9;padding:20px}
select,button,input{padding:8px;margin:4px}
button{background:#00416A;color:#fff;border:none;cursor:pointer}
table{width:100%;border-collapse:collapse;margin-top:20px;background:#fff}
th,td{border:1px solid #ccc;padding:6px;text-align:center}
th{background:#00416A;color:#fff}
.total{margin-top:15px;font-size:18px;font-weight:bold;color:#b00020}
input[type=number]{width:70px}
tr.falta{background:#fff6c2}
</style>
</head>

<body>

<h2>ðŸ“Š Comparador CotizaciÃ³n vs Factura (BD)</h2>

<label>Proveedor:</label>
<select id="proveedor">
  <option value="">-- Selecciona --</option>
  <option value="ABARROTES">ABARROTES</option>
  <option value="DECASA">DECASA</option>
  <option value="MAS BODEGA">MAS BODEGA</option>
</select>

<button onclick="buscarFacturas()">Buscar facturas</button>

<div id="listaFacturas"></div>

<hr>

<label>CotizaciÃ³n (Excel):</label>
<input type="file" id="excelFile" accept=".xlsx,.xls">

<table>
<thead>
<tr>
  <th>Producto</th>
  <th>Cotizado</th>
  <th>Factura</th>
  <th>Pzas x Caja</th>
  <th>Diferencia</th>
  <th>A descontar</th>
</tr>
</thead>
<tbody id="tabla"></tbody>
</table>

<div class="total" id="total"></div>

<script>
/* ================= SUPABASE ================= */
const supa = supabase.createClient(
  "https://cvpbtjlupswbyxenugpz.supabase.co",
  "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImN2cGJ0amx1cHN3Ynl4ZW51Z3B6Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDc3MDIxOTQsImV4cCI6MjA2MzI3ODE5NH0.iiJsYM3TtaGPdeCtPcEXwAz3LfFc1uJGECEvOErvrqY"
);

let conceptosFactura = [];
let cotizadosCache = [];

/* ================= UTILIDADES ================= */
function normalizar(t){
  return String(t ?? "").toUpperCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g,"")
    .replace(/\./g," ")
    .replace(/[+]/g," ")
    .replace(/[^A-Z0-9\s/]/g," ")
    .replace(/\s+/g," ")
    .trim();
}

function limpiarNumero(v){
  if (v === null || v === undefined) return 0;
  // soporta "11.45", "$ 11.45", "11,45"
  const s = String(v).replace(/\$/g,"").replace(/,/g,".").replace(/\s/g,"");
  const n = parseFloat(s);
  return isNaN(n) ? 0 : n;
}
function pickNum(obj, keys){
  for(const k of keys){
    if(obj && obj[k] !== undefined && obj[k] !== null && obj[k] !== "") return limpiarNumero(obj[k]);
  }
  return 0;
}
function pickPath(obj, path){
  // path ejemplo: "impuestos.traslados"
  try{
    return path.split(".").reduce((a,k)=> (a && a[k] !== undefined ? a[k] : undefined), obj);
  }catch(e){
    return undefined;
  }
}
function extraerImpuestoConcepto(c, codigo){
  const posibles = [
    pickPath(c, "impuestos.traslados"),
    pickPath(c, "impuestos.Traslados"),
    pickPath(c, "Impuestos.Traslados"),
    c.traslados,
    c.Traslados
  ].filter(Boolean);

  const normCode = (v) => {
    // puede venir 2, "2", "002", "003"
    let s = String(v ?? "").trim();
    // quita no-dÃ­gitos
    s = s.replace(/\D/g, "");
    if (!s) return "";
    return s.padStart(3, "0"); // "2" -> "002"
  };

  for (const arr of posibles){
    if(!Array.isArray(arr)) continue;

    let suma = 0;
    for (const t of arr){
      const imp = normCode(t.impuesto ?? t.Impuesto ?? t.idImpuesto ?? t.IdImpuesto);
      if (imp !== codigo) continue;

      const importe = pickNum(t, ["importe","Importe","IMPORTE","importe_impuesto","ImporteImpuesto","importeImporte"]);
      suma += importe;
    }
    if (suma > 0) return suma;
  }

  // fallback si vienen planos (como en tu tabla visual â€œIVA / IEPSâ€)
  if (codigo === "002") return pickNum(c, ["iva","IVA","importe_iva","iva_importe","Iva"]);
  if (codigo === "003") return pickNum(c, ["ieps","IEPS","importe_ieps","ieps_importe","Ieps"]);
  return 0;
}

function precioPiezaConImpuestos(c, pzas){
  const { cajas, totalLinea } = totalLineaConImpuestos(c);
  const piezas = Math.max(1, parseInt(pzas) || 1);
  return totalLinea / cajas / piezas; // âœ… precio por pieza con impuestos
}

function extraerPiezas(desc){
  const m = String(desc ?? "").match(/(\d+)\s*\/\s*\d+/);
  return m ? parseInt(m[1]) : null;
}

/* ---- tokens fuertes para matching ---- */
/* ---- tokens fuertes para matching (CON MEDIDAS) ---- */
const STOP = new Set([
  "PARA","CON","DEL","DE","LA","EL","LOS","LAS","Y","EN","AL","UN","UNA","UNO",
  "MAS","PROMO","PROMOCION","PRODUCTO","EXTRA","PACK","PAQ","PQT","CJA","CAJA"
]);

function tokenNorm(tok){
  tok = String(tok || "").replace(/[^A-Z0-9]/g,"");
  if (!tok) return "";

  // Normaliza litros
  tok = tok.replace(/LT$/,"L");

  // Token de medida: 950ML, 177GR, 1KG, 2L, etc.
  if (/^\d+(?:\.\d+)?(ML|GR|G|KG|L)$/.test(tok)) return tok;

  // singular bÃ¡sico (GALLETAS->GALLETA)
  if (tok.length >= 5 && tok.endsWith("S")) tok = tok.slice(0, -1);

  if (STOP.has(tok)) return "";
  if (tok.length < 3) return "";
  return tok;
}

function tokensProducto(texto){
  let s = normalizar(texto);

  // Convierte promos tipo "12/950 ML" -> "950ML" (nos interesa el tamaÃ±o real)
  s = s.replace(/(\d+)\s*\/\s*(\d+)\s*(ML|GR|G|KG|LT|L)\b/g, "$2$3");

  // Extrae medidas aunque vengan separadas "950 ML" o juntas "950ML"
  const medidas = [];
  s.replace(/(\d+(?:\.\d+)?)\s*(ML|GR|G|KG|LT|L)\b/g, (_, num, uni) => {
    uni = uni.replace("LT","L");
    medidas.push(tokenNorm(`${num}${uni}`));
    return _;
  });

  // Quita las medidas del texto base para no duplicar
  s = s.replace(/(\d+(?:\.\d+)?)\s*(ML|GR|G|KG|LT|L)\b/g, " ");

  // Quita nÃºmeros sueltos que no sean medidas (ej: "12" de promo)
  s = s.replace(/\b\d+\b/g, " ");

  // Tokens de palabras
  const palabras = s.split(" ").map(tokenNorm).filter(Boolean);

  // Unifica y regresa
  return Array.from(new Set([...palabras, ...medidas].filter(Boolean)));
}

function scoreMatch(tokensA, tokensB){
  if (!tokensA.length || !tokensB.length) return {score:0, hits:0};
  const setB = new Set(tokensB);
  let hits = 0;
  for (const x of tokensA) if (setB.has(x)) hits++;
  const score = hits / Math.max(tokensA.length, tokensB.length);
  return {score, hits};
}

/* ================= BUSCAR FACTURAS ================= */
async function buscarFacturas(){
  const proveedorSel = document.getElementById("proveedor").value;
  if(!proveedorSel){ alert("Selecciona proveedor"); return }

  const { data, error } = await supa
    .from("deuda_limpia_pdd")
    .select("uuid_cfdi, fecha, total, conceptos_detalle, razon_social_emisor")
    .ilike("razon_social_emisor", `%${proveedorSel}%`)
    .order("fecha",{ascending:false})
    .limit(10);

  if(error){
    console.error(error);
    alert("Error al consultar BD");
    return;
  }

  let html = "<h4>Facturas:</h4><ul>";
  data.forEach(f=>{
    html += `
      <li>
        ${String(f.fecha).split("T")[0]} â€” $${f.total}
        <button onclick='usarFactura(${JSON.stringify(f.conceptos_detalle)})'>Usar</button>
      </li>`;
  });
  html += "</ul>";
  document.getElementById("listaFacturas").innerHTML = html;
}
function totalLineaConImpuestos(c){
  const cajas = pickNum(c, ["cantidad","cant","Cant","CANT","cajas","Cajas","CAJAS"]) || 1;
  const unitario = pickNum(c, ["valorUnitario","unitario","Unitario","UNITARIO","precioUnitario","PrecioUnitario"]);

  let subtotalLinea = pickNum(c, ["subtotal","Subtotal","importe","Importe"]);
  if (!subtotalLinea || subtotalLinea <= 0){
    subtotalLinea = unitario * cajas;
  }

  const iva  = extraerImpuestoConcepto(c, "002");
  const ieps = extraerImpuestoConcepto(c, "003");

  return {
    cajas,
    unitario,
    subtotalLinea,
    iva,
    ieps,
    totalLinea: subtotalLinea + iva + ieps
  };
}

/* ================= USAR FACTURA ================= */
function usarFactura(conceptos){
  // conceptos_detalle puede venir como array o como string JSON
  let arr = conceptos;
  if (typeof arr === "string") {
    try { arr = JSON.parse(arr); } catch(e) { arr = []; }
  }
  if (!Array.isArray(arr)) arr = [];

conceptosFactura = arr.map(c=>{
  const pzas = extraerPiezas(c.descripcion) || 1;

  const calc = totalLineaConImpuestos(c);
  const cajas = calc.cajas;

  // (Unitario + (IVA+IEPS)/cajas) / pzas
  const precioCajaConImp = calc.unitario + ((calc.iva + calc.ieps) / cajas);
  const precioPieza = precioCajaConImp / pzas;

  return {
    descripcionRaw: c.descripcion || "",
    descripcion: normalizar(c.descripcion),
    tokens: tokensProducto(c.descripcion),

    cajas,
    piezasCaja: pzas,

    unitario: calc.unitario,
    ivaLinea: calc.iva,
    iepsLinea: calc.ieps,

    subtotalLinea: calc.subtotalLinea,
    totalLinea: calc.totalLinea,

    precioPieza
  };
});

  procesar();
}

/* ================= PROCESAR ================= */
async function procesar(){
  const proveedorSel = document.getElementById("proveedor").value;
  const file = document.getElementById("excelFile").files[0];

  // si aÃºn no hay factura o excel, no hagas nada (sin alert)
  if (!conceptosFactura.length || !file) return;

  cotizadosCache = await leerExcel(file, proveedorSel);
  comparar(cotizadosCache, conceptosFactura);
}


/* ================= LEER EXCEL (MATRIZ POR PROVEEDOR) ================= */
function leerExcel(file, proveedorSel){
  return new Promise(resolve=>{
    const r = new FileReader();
    r.onload = e=>{
      const wb = XLSX.read(new Uint8Array(e.target.result),{type:'array'});

      const prov = normalizar(proveedorSel);

      // 1) Buscar una hoja donde en alguna fila estÃ© el nombre del proveedor (encabezado matriz)
      let best = null;

      for (const shName of wb.SheetNames){
        const ws = wb.Sheets[shName];
        const rows = XLSX.utils.sheet_to_json(ws,{header:1, raw:true});

        // Buscar fila que tenga "DESCRIPCION" y, arriba o en la misma, el proveedor
        let headerRowIdx = -1;
        for (let i=0; i<Math.min(rows.length, 20); i++){
          const row = rows[i] || [];
          const rowStr = row.map(x=>normalizar(x)).join(" | ");
          if (rowStr.includes("DESCRIPCION")) { headerRowIdx = i; break; }
        }
        if (headerRowIdx === -1) continue;

        // Buscar columna del proveedor en fila headerRowIdx-1 o headerRowIdx
        const r1 = rows[headerRowIdx-1] || [];
        const r2 = rows[headerRowIdx] || [];

        let colProv = -1;

        // intenta en fila de arriba (como tu matriz: fila 2 trae ABARROTES/DECASA)
        for (let j=0; j<r1.length; j++){
          if (normalizar(r1[j]) === prov) { colProv = j; break; }
        }
        // fallback: intenta en la misma fila
        if (colProv === -1){
          for (let j=0; j<r2.length; j++){
            if (normalizar(r2[j]) === prov) { colProv = j; break; }
          }
        }

        if (colProv === -1) continue;

        best = {shName, rows, start: headerRowIdx+1, colDesc: 0, colPrice: colProv};
        break;
      }

      // 2) Fallback si no se encontrÃ³ estructura matriz: hoja 1, col A desc, col B precio
      if (!best){
        const shName = wb.SheetNames[0];
        const ws = wb.Sheets[shName];
        const rows = XLSX.utils.sheet_to_json(ws,{header:1, raw:true});
        best = {shName, rows, start: 1, colDesc: 0, colPrice: 1};
      }

      const out = [];
      for (let i=best.start; i<best.rows.length; i++){
        const row = best.rows[i] || [];
        const desc = row[best.colDesc];
        if (!desc) continue;

        const precio = limpiarNumero(row[best.colPrice]);
        if (!precio || precio <= 0) continue;

        const descNorm = normalizar(desc);

        out.push({
          descripcionRaw: String(desc),
          descripcion: descNorm,
          tokens: tokensProducto(descNorm),
          precio
        });
      }

      resolve(out);
    };
    r.readAsArrayBuffer(file);
  });
}

/* ================= COMPARAR (MATCH POR SCORE) ================= */
function comparar(cotizados, facturados){
  const tbody = document.getElementById("tabla");
  tbody.innerHTML="";
  let total=0;

  facturados.forEach((f, idx)=>{
    // piezas
    const pzas = (f.piezasCaja && f.piezasCaja > 0) ? Number(f.piezasCaja) : 1;

// âœ… la factura YA es por pieza con impuestos
const precioUnitFact = f.precioPieza;

    // buscar mejor match
    let best = null;
    let bestScore = 0;
    let bestHits = 0;

    for (const x of cotizados){
      const {score, hits} = scoreMatch(f.tokens, x.tokens);
      if (score > bestScore || (score === bestScore && hits > bestHits)){
        bestScore = score;
        bestHits = hits;
        best = x;
      }
    }

    // umbral: 2 hits o score >= 0.55
    const ok = best && (bestHits >= 2 || bestScore >= 0.55);

    const precioCot = ok ? best.precio : 0;
    const diferencia = ok ? (precioUnitFact - precioCot) : 0;

    const descuento = (ok && diferencia > 0)
      ? diferencia * pzas * f.cajas
      : 0;

    total += descuento;

    tbody.innerHTML += `
      <tr class="${!ok ? 'falta' : (!f.piezasCaja ? 'falta' : '')}">
        <td>${f.descripcion}</td>
        <td>${ok ? precioCot.toFixed(2) : "â€”"}</td>
        <td>${precioUnitFact.toFixed(2)}</td>
        <td>
          <input type="number" min="1" value="${pzas}"
            onchange="actualizarPiezas(${idx}, this.value)">
        </td>
        <td>${diferencia.toFixed(2)}</td>
        <td>${descuento.toFixed(2)}</td>
      </tr>`;
  });

  document.getElementById("total").innerText =
    "TOTAL A DESCONTAR: $ " + total.toFixed(2);
}

/* ================= RECALCULO PZAS ================= */
function actualizarPiezas(idx, valor){
  const pzas = Math.max(1, parseInt(valor) || 1);

  const item = conceptosFactura[idx];
  item.piezasCaja = pzas;

  const cajas = item.cajas || 1;
  const unitario = item.unitario || 0;
  const iva = item.ivaLinea || 0;
  const ieps = item.iepsLinea || 0;

  const precioCajaConImp = unitario + ((iva + ieps) / cajas);
  item.precioPieza = precioCajaConImp / pzas;

  comparar(cotizadosCache, conceptosFactura);
}
</script>

</body>
</html>
